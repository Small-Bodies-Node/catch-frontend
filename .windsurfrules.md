# Windsurf Rules for TypeScript Projects

## Project Context

- This project uses TypeScript for type safety and maintainability.
- All code should follow a functional programming style where possible, minimizing side effects and emphasizing pure functions.
- JavaScript/TypeScript modules can be used as "functional units" (e.g., for maintaining state like counters) when needed.

## TypeScript-Specific Rules

- **Interfaces**: All interface names must start with a capital `I` (e.g., `IUser`, `IProduct`).
- **Types**: All type aliases must start with a capital `T` (e.g., `TStatus`, `TConfig`).
- **File Location**: All interfaces and types must be defined in files within the `src/models` folder.
- **File Separation**: Prefer placing each interface or type in its own separate file (e.g., `src/models/IUser.ts`, `src/models/TStatus.ts`) unless they are tightly coupled and small in scope.
- **Functional Style**:
  - Write code as composable, pure functions with minimal side effects.
  - Avoid mutating state directly; use immutable patterns (e.g., spread operators, `Object.assign`).
  - Leverage module exports as functional units when state (e.g., a counter) is required—treat these as encapsulated, reusable blocks.

## General Coding Conventions

- **Naming**: Use camelCase for variables and functions (e.g., `getUserData`, `userId`).
- **Explicitness**: Prefer explicit return types in functions for better type inference and readability (e.g., `function getName(): string`).
- **Imports**: Use named imports over default imports for clarity (e.g., `import { useState } from 'react'` instead of `import useState from 'react'`).
- **Error Handling**: Always handle errors in async functions with try/catch or `.catch()` for Promises.

## Classic Principles

- **KISS**: Keep code simple and avoid over-engineering. Choose the simplest solution that meets requirements.
- **SSOT**: Maintain a single source of truth for data and types—avoid duplicating definitions across files.

## Additional Best Practices

- **DRY (Don’t Repeat Yourself)**: Reuse functions, types, and utilities to avoid redundant code.
- **YAGNI (You Aren’t Gonna Need It)**: Don’t add functionality or complexity unless it’s currently required.
- **SOLID Principles** (Adapted for TS/FP):
  - **Single Responsibility**: Each function or module should have one clear purpose.
  - **Open/Closed**: Design code to be extensible without modifying existing logic (e.g., via composition).
  - **Liskov Substitution**: Ensure subtypes (if used) can replace their base types without breaking behavior.
  - **Interface Segregation**: Keep interfaces small and focused—avoid "fat" interfaces.
  - **Dependency Inversion**: Depend on abstractions (e.g., interfaces) rather than concrete implementations.
- **Documentation**: Add JSDoc comments for complex functions, interfaces, and types (e.g., `/** Description */`).
- **Consistency**: Follow the existing codebase’s style for indentation (2 spaces), line breaks, and file naming.

## Project Workflow

- Start coding sessions with: "Starting Windsurf session for TypeScript project..."
- Use `npm` for package management (e.g., `npm install`, not `yarn` or `pnpm`).
- Organize files logically under `src/` (e.g., `src/components/`, `src/utils/`, `src/models/`).
- User likes to operate codebase with bash scripts in the root dir prefixed with `_`

## Misc

- When thinking/speaking, communicate to me with he/him/his
- prefer not to create scripts for one-time usage; such scripts need to be deleted afterwards
